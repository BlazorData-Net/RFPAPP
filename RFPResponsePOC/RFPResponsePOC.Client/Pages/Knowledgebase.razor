@page "/knowledgebase"
@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@using System.Text
@using System.IO
@using System.Collections.Generic
@using System.Linq
@using BlazorWebAssemblyPDF.Services
@using Newtonsoft.Json
@using RFPResponseAPP.Client.Models
@using RFPResponseAPP.Client.Services
@using RFPResponseAPP.AI
@using Microsoft.AspNetCore.Components.Forms
@using RFPResponseAPP.Model
@using Radzen
@using Radzen.Blazor
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject LogService LogService
@inject SettingsService _SettingsService
@inject NavigationManager Navigation
@inject PdfToPngService PdfService
@inject HttpClient Http
@inject IJSRuntime JsRuntime
@inject KnowledgebaseService KnowledgebaseService
@inject KnowledgebaseTokenService KnowledgebaseTokenService
@if (@InProgress)
{
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                                background-color: rgba(0,0,0,0.5); z-index: 1000;
                                display: flex; align-items: center; justify-content: center;">
        <div class="rz-card" style="padding: 20px;">
            <RadzenText Text="@CurrentStatus" class="rz-m-10" Style="text-align: center" />
            <RadzenProgressBar Value="100" ShowValue="false" Mode="ProgressBarMode.Indeterminate" />
        </div>
    </div>
}
<RadzenTabs RenderMode="TabRenderMode.Client">
    <Tabs>
    <RadzenTabsItem Text="Knowledgebase Management">
        <div style="padding: 20px;">
            <RadzenUpload @ref="uploader"
                              ChooseText="Upload Knowledgebase content (.txt/.pdf/.png/.jpg/.jpeg)" Accept=".txt,.pdf,.png,.jpg,.jpeg"
                              Change=@OnFileUpload
                              Multiple="false"
                              Auto="true"
                              Style="width: 100%"
                              InputAttributes="@(new Dictionary<string,object>{{"aria-label","select file"}})">
            </RadzenUpload>
            <br /><br />
            <RadzenButton Text="Add Row" Icon="add" Style="margin-bottom:10px" ButtonStyle="ButtonStyle.Primary" Click="InsertRow" />
            
            <RadzenButton Text="Save Knowledgebase" Icon="save" Style="margin-left:10px;margin-bottom:10px;background-color:green;" ButtonStyle="ButtonStyle.Primary" Click="@((async () => await KnowledgebaseService.SaveKnowledgebaseDataAsync(entries)))" />
            
            @if (entries?.Any() == true)
            {
                <RadzenDataGrid @ref="grid"
                                Data="@groupedEntries"
                                TItem="KnowledgeEntry"
                                AllowPaging="false"
                                ExpandMode="DataGridExpandMode.Single">
                    <Columns>
                        <RadzenDataGridColumn TItem="KnowledgeEntry" Filterable="false" Sortable="false" Width="60px" TextAlign="TextAlign.Center" Title="DEL">
                            <Template Context="entry">
                                <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger" Size="ButtonSize.ExtraSmall" Click="@(() => ConfirmDeleteEntryGroup(entry.EntryTitle))" @onclick:stopPropagation="true" />
                            </Template>
                        </RadzenDataGridColumn>
                        <RadzenDataGridColumn TItem="KnowledgeEntry" Property="EntryTitle" Title="Entry Title" />
                    </Columns>
                    <Template Context="entry">
                        <RadzenDataGrid Data="entry.Chunks" TItem="KnowledgeChunk" AllowPaging="false">
                            <Columns>
                                <RadzenDataGridColumn TItem="KnowledgeChunk" Filterable="false" Sortable="false" Width="110px" TextAlign="TextAlign.Center" Title="EDIT/DEL">
                                    <Template Context="chunk">
                                        <RadzenButton Icon="edit" ButtonStyle="ButtonStyle.Light" Size="ButtonSize.ExtraSmall" Click="@(() => EditRow(chunk))" @onclick:stopPropagation="true" />
                                        <span>&nbsp;</span>
                                        <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger" Size="ButtonSize.ExtraSmall" Click="@(() => ConfirmDeleteRow(chunk))" @onclick:stopPropagation="true" />
                                    </Template>
                                </RadzenDataGridColumn>
                                <RadzenDataGridColumn TItem="KnowledgeChunk" Property="Content" Title="Content">
                                    <Template Context="chunk">
                                        <div style="white-space:pre-wrap">@chunk.Content</div>
                                    </Template>
                                </RadzenDataGridColumn>
                            </Columns>
                        </RadzenDataGrid>
                    </Template>
                </RadzenDataGrid>
            }
            else
            {
                <div class="rz-p-4" style="text-align: center; color: #666;">
                    <p>No knowledgebase entries found. Upload a document or click "Add Row" to get started.</p>
                </div>
            }
        </div>
    </RadzenTabsItem>
    <RadzenTabsItem Text="Token Management">
        <div style="padding: 20px;">
            <RadzenButton Text="Add Token" Icon="add" Style="margin-bottom:10px" ButtonStyle="ButtonStyle.Primary" Click="InsertToken" />
            
            <RadzenButton Text="Save Tokens" Icon="save" Style="margin-left:10px;margin-bottom:10px;background-color:green;" ButtonStyle="ButtonStyle.Primary" Click="@((async () => await KnowledgebaseTokenService.SaveKnowledgebaseTokensDataAsync(tokens)))" />
            
            @if (tokens?.Any() == true)
            {
                <RadzenDataGrid @ref="tokenGrid" Data="@tokens" TItem="KnowledgeToken" AllowPaging="false">
                    <Columns>
                        <RadzenDataGridColumn TItem="KnowledgeToken" Filterable="false" Sortable="false" Width="110px" TextAlign="TextAlign.Center" Title="EDIT/DEL">
                            <Template Context="token">
                                <RadzenButton Icon="edit" ButtonStyle="ButtonStyle.Light" Size="ButtonSize.ExtraSmall" Click="@(() => EditToken(token))" @onclick:stopPropagation="true" />
                                <span>&nbsp;</span>
                                <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger" Size="ButtonSize.ExtraSmall" Click="@(() => ConfirmDeleteToken(token))" @onclick:stopPropagation="true" />
                            </Template>
                        </RadzenDataGridColumn>
                        <RadzenDataGridColumn TItem="KnowledgeToken" Property="Token" Title="Token" />
                        <RadzenDataGridColumn TItem="KnowledgeToken" Property="Value" Title="Value">
                            <Template Context="t">
                                <div style="white-space:pre-wrap">@t.Value</div>
                            </Template>
                        </RadzenDataGridColumn>
                    </Columns>
                </RadzenDataGrid>
            }
            else
            {
                <div class="rz-p-4" style="text-align: center; color: #666;">
                    <p>No tokens found. Click "Add Token" to create your first token.</p>
                </div>
            }
        </div>
    </RadzenTabsItem>
    </Tabs>
</RadzenTabs>

<br />
<br />
<br />
<br />
<br />
<br />
<canvas id="pdfCanvas" style="display:none; border:1px solid #ccc;"></canvas>

@code {
#nullable disable
    private IDisposable registration;
    // Allow access to the JSRuntime
    private DotNetObjectReference<Knowledgebase> objRef;
    ZipService objZipService = new ZipService();
    Radzen.Blazor.RadzenUpload uploader;
    Radzen.Blazor.RadzenDataGrid<KnowledgeEntry> grid;
    Radzen.Blazor.RadzenDataGrid<KnowledgeToken> tokenGrid;
    List<KnowledgeChunk> entries = new();
    List<KnowledgeToken> tokens = new();
    IEnumerable<KnowledgeEntry> groupedEntries => entries
        .GroupBy(e => e.EntryTitle)
        .Select(g => new KnowledgeEntry { EntryTitle = g.Key, Chunks = g.ToList() });
    OrchestratorMethods objOrchestratorMethods;
    private bool InProgress = false;
    private string CurrentStatus = "";
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Set a reference to the current instance
                objRef = DotNetObjectReference.Create(this);

                // Register the beforeunload event with JavaScript
                await JsRuntime.InvokeVoidAsync("setupBeforeUnload", objRef);

                // Register the location changing handler
                registration = Navigation.RegisterLocationChangingHandler(OnLocationChanging);

                // Initialize the ZipService
                objZipService = new ZipService(JsRuntime, localStorage, _SettingsService, LogService);

                objOrchestratorMethods = new OrchestratorMethods(_SettingsService, LogService);
                
                // Load knowledgebase data
                var json = await KnowledgebaseService.GetKnowledgebaseJsonAsync();
                if (!string.IsNullOrWhiteSpace(json))
                {
                    try
                    {
                        entries = JsonConvert.DeserializeObject<List<KnowledgeChunk>>(json) ?? new();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error deserializing knowledgebase data: {ex.Message}");
                        entries = new();
                    }
                }
                else
                {
                    Console.WriteLine("No knowledgebase data found, starting with empty list");
                    entries = new();
                }

                // Load tokens data
                var tokenJson = await KnowledgebaseTokenService.GetKnowledgebaseTokenJsonAsync();
                if (!string.IsNullOrWhiteSpace(tokenJson))
                {
                    try
                    {
                        tokens = JsonConvert.DeserializeObject<List<KnowledgeToken>>(tokenJson) ?? new();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error deserializing token data: {ex.Message}");
                        tokens = new();
                    }
                }
                else
                {
                    Console.WriteLine("No token data found, starting with empty list");
                    tokens = new();
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in OnAfterRenderAsync: {ex.Message}");
                // Ensure we have empty lists even if there's an error
                entries = entries ?? new();
                tokens = tokens ?? new();
                StateHasChanged();
            }
        }
    }

    #region JavaScript
    private ValueTask OnLocationChanging(LocationChangingContext context)
    {
        // Get the base URL
        string baseUrl = Navigation.BaseUri;

        // Detect that user is going to counter page
        if (context.TargetLocation != baseUrl)
        {
            // User is navigating away from the page - Zip any files
            // Zip up any files and store in LocalStorage
            Task.Run(async () => await objZipService.ZipTheFiles());
        }

        return ValueTask.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleBeforeUnload()
    {
        // User is navigating away from the page - Zip any files
        // Zip up any files and store in LocalStorage
        await objZipService.ZipTheFiles();
    }
    #endregion
    
    async Task OnFileUpload(UploadChangeEventArgs e)
    {
        var file = e.Files.FirstOrDefault();
        if (file == null) return;

        var dialogResult = await DialogService.OpenAsync<KnowledgeChunkDialog>("Entry Title", new Dictionary<string, object>()
        {
            {"Chunk", new KnowledgeChunk()},
            {"ShowContent", false}
        });
        var titleChunk = dialogResult as KnowledgeChunk;
        if (titleChunk == null || string.IsNullOrWhiteSpace(titleChunk.EntryTitle))
        {
            await uploader.ClearFiles();
            return;
        }

        InProgress = true;
        CurrentStatus = "Processing...";
        StateHasChanged();

        string content = string.Empty;

        try
        {
            // Handle PDFs and images via OCR
            if (file.ContentType == "application/pdf" || file.ContentType.StartsWith("image/"))
            {
                CurrentStatus = $"Reading File...";
                StateHasChanged();

                var OCRprompt = await Http.GetStringAsync("Prompts/OCR.prompt");
                var settingsService = new SettingsService();

                if (file.ContentType == "application/pdf")
                {
                    var pages = await PdfService.GetPdfPagesAsPngBytesAsync(file);
                    for (int pageIndex = 0; pageIndex < pages.Count; pageIndex++)
                    {
                        CurrentStatus = $"Processing page {pageIndex + 1} of {pages.Count}";
                        StateHasChanged();

                        var result = await objOrchestratorMethods.CallOpenAIFileAsync(settingsService, OCRprompt, pages[pageIndex]);

                        if (!string.IsNullOrWhiteSpace(result.Error))
                        {
                            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = result.Error, Duration = 4000 });
                            return;
                        }

                        content += result.Response + " ";
                    }
                }
                else
                {
                    using var imgStream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
                    using var ms = new MemoryStream();
                    await imgStream.CopyToAsync(ms);
                    var imageBytes = ms.ToArray();

                    var result = await objOrchestratorMethods.CallOpenAIFileAsync(settingsService, OCRprompt, imageBytes);

                    if (!string.IsNullOrWhiteSpace(result.Error))
                    {
                        NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = result.Error, Duration = 4000 });
                        return;
                    }

                    content = result.Response;
                }
            }
            else
            {
                CurrentStatus = $"Processing File...";
                StateHasChanged();

                using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
                using var reader = new StreamReader(stream);
                content = await reader.ReadToEndAsync();
            }

            var words = content.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < words.Length; i += 200)
            {
                CurrentStatus = $"Processing chunk {i / 200 + 1} of {Math.Ceiling((double)words.Length / 200)}";
                StateHasChanged();

                var chunkWords = words.Skip(i).Take(200);
                var chunkText = string.Join(" ", chunkWords);
                var embedding = await objOrchestratorMethods.GetVectorEmbeddingAsync(chunkText, true);
                entries.Add(new KnowledgeChunk { Id = Guid.NewGuid().ToString(), EntryTitle = titleChunk.EntryTitle, Content = chunkText, Embedding = embedding });
            }

            await grid.Reload();
            await KnowledgebaseService.SaveKnowledgebaseDataAsync(entries);
            await uploader.ClearFiles();

            InProgress = false;
            CurrentStatus = "";

            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = "Uploaded", Detail = "Document processed", Duration = 4000 });
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await LogService.WriteToLogAsync($"[{DateTime.Now}] OnFileUpload - {ex.Message}");

            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = $"{ex.Message}", Duration = 4000 });
            InProgress = false;
            return;
        }
    }
    
    async Task EditRow(KnowledgeChunk chunk)
    {
        var editModel = new KnowledgeChunk { Id = chunk.Id, EntryTitle = chunk.EntryTitle, Content = chunk.Content };
        var dialogResult = await DialogService.OpenAsync<KnowledgeChunkDialog>("Edit Entry", new Dictionary<string, object>()
        {
            {"Chunk", editModel},
            {"ShowContent", true}
        });
        var result = dialogResult as KnowledgeChunk;
        if (result != null)
        {
            chunk.EntryTitle = result.EntryTitle;
            chunk.Content = result.Content;
            chunk.Embedding = await objOrchestratorMethods.GetVectorEmbeddingAsync(chunk.Content, false);
            await KnowledgebaseService.SaveKnowledgebaseDataAsync(entries);
            await grid.Reload();
        }
    }

    private async Task ConfirmDeleteRow(KnowledgeChunk chunk)
    {
        var confirmed = await DialogService.Confirm(
            "Are you sure you want to delete this row?",
            "Confirm Delete",
            new ConfirmOptions
            {
                OkButtonText = "Delete",
                CancelButtonText = "Cancel"
            });

        if (confirmed == true)
        {
            await DeleteRow(chunk);
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Deleted",
                Detail = "Row removed.",
                Duration = 3000
            });
        }
    }

    private async Task ConfirmDeleteEntryGroup(string entryTitle)
    {
        var chunksToDelete = entries.Where(e => e.EntryTitle == entryTitle).ToList();
        var confirmed = await DialogService.Confirm(
            $"Are you sure you want to delete all {chunksToDelete.Count} chunks for '{entryTitle}'?",
            "Confirm Delete Entry Group",
            new ConfirmOptions
            {
                OkButtonText = "Delete All",
                CancelButtonText = "Cancel"
            });

        if (confirmed == true)
        {
            await DeleteEntryGroup(entryTitle);
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Deleted",
                Detail = $"Entry group '{entryTitle}' and all its chunks removed.",
                Duration = 3000
            });
        }
    }

    async Task DeleteRow(KnowledgeChunk chunk)
    {
        if (entries.Contains(chunk))
        {
            entries.Remove(chunk);
            await grid.Reload();
            await KnowledgebaseService.SaveKnowledgebaseDataAsync(entries);
        }
    }

    async Task DeleteEntryGroup(string entryTitle)
    {
        var chunksToRemove = entries.Where(e => e.EntryTitle == entryTitle).ToList();
        foreach (var chunk in chunksToRemove)
        {
            entries.Remove(chunk);
        }
        await grid.Reload();
        await KnowledgebaseService.SaveKnowledgebaseDataAsync(entries);
    }

    async Task InsertRow()
    {
        var newChunk = new KnowledgeChunk { Id = Guid.NewGuid().ToString() };
        var dialogResult = await DialogService.OpenAsync<KnowledgeChunkDialog>("Add Entry", new Dictionary<string, object>()
        {
            {"Chunk", newChunk},
            {"ShowContent", true}
        });
        var result = dialogResult as KnowledgeChunk;
        if (result != null && !string.IsNullOrWhiteSpace(result.EntryTitle))
        {
            result.Embedding = await objOrchestratorMethods.GetVectorEmbeddingAsync(result.Content, true);
            entries.Insert(0, result);
            await KnowledgebaseService.SaveKnowledgebaseDataAsync(entries);

            if (grid != null)
            {
                await grid.Reload();
            }
        }
    }

    async Task InsertToken()
    {
        var newToken = new KnowledgeToken { Id = Guid.NewGuid().ToString() };
        var dialogResult = await DialogService.OpenAsync<KnowledgeTokenDialog>("Add Token", new Dictionary<string, object>()
        {
            {"Token", newToken}
        });
        var result = dialogResult as KnowledgeToken;
        if (result != null && !string.IsNullOrWhiteSpace(result.Token))
        {
            tokens.Insert(0, result);
            await KnowledgebaseTokenService.SaveKnowledgebaseTokensDataAsync(tokens);

            if (tokenGrid != null)
            {
                await tokenGrid.Reload();
            }
        }
    }

    async Task EditToken(KnowledgeToken token)
    {
        var editModel = new KnowledgeToken { Id = token.Id, Token = token.Token, Value = token.Value };
        var dialogResult = await DialogService.OpenAsync<KnowledgeTokenDialog>("Edit Token", new Dictionary<string, object>()
        {
            {"Token", editModel}
        });
        var result = dialogResult as KnowledgeToken;
        if (result != null)
        {
            token.Token = result.Token;
            token.Value = result.Value;
            await KnowledgebaseTokenService.SaveKnowledgebaseTokensDataAsync(tokens);
            await tokenGrid.Reload();
        }
    }

    private async Task ConfirmDeleteToken(KnowledgeToken token)
    {
        var confirmed = await DialogService.Confirm(
            "Are you sure you want to delete this token?",
            "Confirm Delete",
            new ConfirmOptions
            {
                OkButtonText = "Delete",
                CancelButtonText = "Cancel",
            });

        if (confirmed == true)
        {
            await DeleteToken(token);
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Deleted",
                Detail = "Token removed.",
                Duration = 3000
            });
        }
    }

    async Task DeleteToken(KnowledgeToken token)
    {
        if (tokens.Contains(token))
        {
            tokens.Remove(token);
            await tokenGrid.Reload();
            await KnowledgebaseTokenService.SaveKnowledgebaseTokensDataAsync(tokens);
        }
    }

    public void Dispose()
    {
        // Remove the beforeunload callback when component is disposed
        if (objRef != null)
        {
            try
            {
                JsRuntime.InvokeVoidAsync("removeBeforeUnloadCallback", objRef);
            }
            catch (Exception)
            {
                // Ignore errors during disposal
            }
            objRef?.Dispose();
        }
        
        registration?.Dispose();
    }

    class KnowledgeEntry
    {
        public string EntryTitle { get; set; }
        public List<KnowledgeChunk> Chunks { get; set; }
    }
}
