@page "/knowledgebase"
@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@using System.Text
@using System.IO
@using System.Collections.Generic
@using System.Linq
@using BlazorWebAssemblyPDF.Services
@using Newtonsoft.Json
@using RFPResponsePOC.Client.Models
@using RFPResponsePOC.Client.Services
@using RFPResponsePOC.AI
@using Microsoft.AspNetCore.Components.Forms
@using RFPResponsePOC.Model
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject LogService LogService
@inject SettingsService _SettingsService
@inject NavigationManager Navigation
@inject PdfToPngService PdfService
@inject HttpClient Http
<h3>Knowledgebase</h3>
<RadzenUpload @ref="uploader"
              ChooseText="Upload document (.txt/.pdf/.png/.jpg/.jpeg)" Accept=".txt,.pdf,.png,.jpg,.jpeg"
              Change=@OnFileUpload
              Multiple="false"
              Auto="true"
              Style="width: 100%"
              InputAttributes="@(new Dictionary<string,object>{{"aria-label","select file"}})">
</RadzenUpload>
<br />
@if (@InProgress)
{
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); z-index: 1000;
            display: flex; align-items: center; justify-content: center;">
        <div class="rz-card" style="padding: 20px;">
            <RadzenText Text="@CurrentStatus" class="rz-m-10" Style="text-align: center" />
            <RadzenProgressBar Value="100" ShowValue="false" Mode="ProgressBarMode.Indeterminate" />
        </div>
    </div>
}
<br />
<RadzenButton Text="Add Row" Icon="add" Style="margin-bottom:10px" ButtonStyle="ButtonStyle.Primary" Click="InsertRow" />
@if (entries?.Any() == true)
{
    <RadzenButton Text="Save Knowledgebase" Icon="save" Style="margin-left:10px;margin-bottom:10px;background-color:green;" ButtonStyle="ButtonStyle.Primary" Click="SaveKnowledgebaseData" />
    <RadzenDataGrid @ref="grid"
                    Data="@entries"
                    TItem="KnowledgeChunk"
                    AllowPaging="false"
                    AllowGrouping="true"
                    Render="@OnGridRender">
        <Columns>
            <RadzenDataGridColumn TItem="KnowledgeChunk"
                                  Property="EntryTitle"
                                  Title="Entry Title"
                                  Groupable="true"
                                  Visible="false" />
            <RadzenDataGridColumn TItem="KnowledgeChunk" Filterable="false" Sortable="false" Width="110px" TextAlign="TextAlign.Center" Title="EDIT/DEL">
                <Template Context="chunk">
                    <RadzenButton Icon="edit" ButtonStyle="ButtonStyle.Light" Size="ButtonSize.ExtraSmall" Click="@(() => EditRow(chunk))" @onclick:stopPropagation="true" />
                    <span>&nbsp;</span>
                    <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger" Size="ButtonSize.ExtraSmall" Click="@(() => ConfirmDeleteRow(chunk))" @onclick:stopPropagation="true" />
                </Template>
            </RadzenDataGridColumn>
            <RadzenDataGridColumn TItem="KnowledgeChunk" Property="EntryTitle" Title="Title" Width="100px">
                 <Template Context="chunk">
                    <div style="white-space:pre-wrap">@chunk.EntryTitle</div>
                </Template>
            </RadzenDataGridColumn>
            <RadzenDataGridColumn TItem="KnowledgeChunk" Property="Content" Title="Content">
                <Template Context="chunk">
                    <div style="white-space:pre-wrap">@chunk.Content</div>
                </Template>
            </RadzenDataGridColumn>
        </Columns>
    </RadzenDataGrid>
}
<br />
<br />
<br />
<br />
<br />
<br />
<canvas id="pdfCanvas" style="display:none; border:1px solid #ccc;"></canvas>
@code {
    #nullable disable
    string BasePath = @"/RFPResponsePOC";
    Radzen.Blazor.RadzenUpload uploader;
    Radzen.Blazor.RadzenDataGrid<KnowledgeChunk> grid;
    List<KnowledgeChunk> entries = new();
    OrchestratorMethods objOrchestratorMethods;
    private bool InProgress = false;
    private string CurrentStatus = "";
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objOrchestratorMethods = new OrchestratorMethods(_SettingsService, LogService);
            var json = await GetKnowledgebaseJsonAsync();
            if (!string.IsNullOrWhiteSpace(json))
            {
                entries = JsonConvert.DeserializeObject<List<KnowledgeChunk>>(json) ?? new();
                StateHasChanged();
            }
        }
    }
    async Task OnFileUpload(UploadChangeEventArgs e)
    {
        var file = e.Files.FirstOrDefault();
        if (file == null) return;

        var dialogResult = await DialogService.OpenAsync<KnowledgeChunkDialog>("Entry Title", new Dictionary<string, object>()
        {
            {"Chunk", new KnowledgeChunk()},
            {"ShowContent", false}
        });
        var titleChunk = dialogResult as KnowledgeChunk;
        if (titleChunk == null || string.IsNullOrWhiteSpace(titleChunk.EntryTitle))
        {
            await uploader.ClearFiles();
            return;
        }

        InProgress = true;
        CurrentStatus = "Processing...";
        StateHasChanged();

        string content = string.Empty;

        try
        {
            // Handle PDFs and images via OCR
            if (file.ContentType == "application/pdf" || file.ContentType.StartsWith("image/"))
            {
                CurrentStatus = $"Reading File...";
                StateHasChanged();

                var OCRprompt = await Http.GetStringAsync("Prompts/OCR.prompt");
                var settingsService = new SettingsService();

                if (file.ContentType == "application/pdf")
                {
                    var pages = await PdfService.GetPdfPagesAsPngBytesAsync(file);
                    for (int pageIndex = 0; pageIndex < pages.Count; pageIndex++)
                    {
                        CurrentStatus = $"Processing page {pageIndex + 1} of {pages.Count}";
                        StateHasChanged();

                        var result = await objOrchestratorMethods.CallOpenAIFileAsync(settingsService, OCRprompt, pages[pageIndex]);

                        if (!string.IsNullOrWhiteSpace(result.Error))
                        {
                            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = result.Error, Duration = 4000 });
                            return;
                        }

                        content += result.Response + " ";
                    }
                }
                else
                {
                    using var imgStream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
                    using var ms = new MemoryStream();
                    await imgStream.CopyToAsync(ms);
                    var imageBytes = ms.ToArray();

                    var result = await objOrchestratorMethods.CallOpenAIFileAsync(settingsService, OCRprompt, imageBytes);

                    if (!string.IsNullOrWhiteSpace(result.Error))
                    {
                        NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = result.Error, Duration = 4000 });
                        return;
                    }

                    content = result.Response;
                }
            }
            else
            {
                CurrentStatus = $"Processing File...";
                StateHasChanged();

                using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
                using var reader = new StreamReader(stream);
                content = await reader.ReadToEndAsync();
            }

            var words = content.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < words.Length; i += 200)
            {
                CurrentStatus = $"Processing chunk {i / 200 + 1} of {Math.Ceiling((double)words.Length / 200)}";
                StateHasChanged();

                var chunkWords = words.Skip(i).Take(200);
                var chunkText = string.Join(" ", chunkWords);
                var embedding = await objOrchestratorMethods.GetVectorEmbeddingAsync(chunkText, true);
                entries.Add(new KnowledgeChunk { Id = Guid.NewGuid().ToString(), EntryTitle = titleChunk.EntryTitle, Content = chunkText, Embedding = embedding });
            }

            await grid.Reload();
            await SaveKnowledgebaseData();
            await uploader.ClearFiles();

            InProgress = false;
            CurrentStatus = "";

            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Success, Summary = "Uploaded", Detail = "Document processed", Duration = 4000 });
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await LogService.WriteToLogAsync($"[{DateTime.Now}] OnFileUpload - {ex.Message}");

            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = $"{ex.Message}", Duration = 4000 });
            InProgress = false;
            return;
        }
    }
    async Task EditRow(KnowledgeChunk chunk)
    {
        var editModel = new KnowledgeChunk { Id = chunk.Id, EntryTitle = chunk.EntryTitle, Content = chunk.Content };
        var dialogResult = await DialogService.OpenAsync<KnowledgeChunkDialog>("Edit Entry", new Dictionary<string, object>()
        {
            {"Chunk", editModel},
            {"ShowContent", true}
        });
        var result = dialogResult as KnowledgeChunk;
        if (result != null)
        {
            chunk.EntryTitle = result.EntryTitle;
            chunk.Content = result.Content;
            chunk.Embedding = await objOrchestratorMethods.GetVectorEmbeddingAsync(chunk.Content, false);
            await SaveKnowledgebaseData();
            await grid.Reload();
        }
    }

    private async Task ConfirmDeleteRow(KnowledgeChunk chunk)
    {
        var confirmed = await DialogService.Confirm(
            "Are you sure you want to delete this row?",
            "Confirm Delete",
            new ConfirmOptions
            {
                OkButtonText = "Delete",
                CancelButtonText = "Cancel"
            });

        if (confirmed == true)
        {
            await DeleteRow(chunk);
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Deleted",
                Detail = "Row removed.",
                Duration = 3000
            });
        }
    }

    async Task DeleteRow(KnowledgeChunk chunk)
    {
        if (entries.Contains(chunk))
        {
            entries.Remove(chunk);
            await grid.Reload();
            await SaveKnowledgebaseData();
        }
    }

    async Task InsertRow()
    {
        var newChunk = new KnowledgeChunk { Id = Guid.NewGuid().ToString() };
        var dialogResult = await DialogService.OpenAsync<KnowledgeChunkDialog>("Add Entry", new Dictionary<string, object>()
        {
            {"Chunk", newChunk},
            {"ShowContent", true}
        });
        var result = dialogResult as KnowledgeChunk;
        if (result != null && !string.IsNullOrWhiteSpace(result.EntryTitle))
        {
            result.Embedding = await objOrchestratorMethods.GetVectorEmbeddingAsync(result.Content, true);
            entries.Insert(0, result);
            await SaveKnowledgebaseData();
            await grid.Reload();
        }
    }

    void OnGridRender(DataGridRenderEventArgs<KnowledgeChunk> args)
    {
        if (args.FirstRender)
        {
            args.Grid.Groups.Add(new GroupDescriptor
            {
                Property = nameof(KnowledgeChunk.EntryTitle),
                SortOrder = SortOrder.Ascending
            });
        }
    }

    async Task SaveKnowledgebaseData()
    {
        var json = JsonConvert.SerializeObject(entries, Formatting.Indented);
        await File.WriteAllTextAsync($"{BasePath}//knowledgebase.json", json);
    }

    private async Task<string> GetKnowledgebaseJsonAsync()
    {
        try
        {
            if (File.Exists($"{BasePath}//knowledgebase.json"))
            {
                return await File.ReadAllTextAsync($"{BasePath}//knowledgebase.json");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading knowledgebase.json: {ex.Message}");
        }
        return null;
    }
}
