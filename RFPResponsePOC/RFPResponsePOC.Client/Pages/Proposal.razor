@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@using System.Text
@using System.Collections.Generic
@using BlazorWebAssemblyPDF.Services
@using Newtonsoft.Json
@using RFPResponsePOC.Client.Services
@using RFPResponsePOC.Model
@using Microsoft.AspNetCore.Components.Forms
@using RFPResponsePOC.AI
@using System.IO
@using Openize.Words
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject IJSRuntime JsRuntime
@inject LogService LogService
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject SettingsService _SettingsService
@inject NavigationManager Navigation
@inject PdfToPngService PdfService
@inject IJSRuntime JsRuntime
@inject HttpClient Http
<h3>Proposal</h3>
<RadzenButton Text="Edit Template" Icon="edit" Style="background-color: green; margin-top:10px;" ButtonStyle="ButtonStyle.Primary" Click="EditTemplate" />
<br />
<br />
<RadzenUpload @ref="uploader"
              ChooseText="Upload Proposal chart (.docx/.pdf/.png/.jpg/.jpeg)" Accept=".docx,.png,.jpg,.jpeg,.pdf"
              Change=@OnProposalUpload
              Multiple="false"
              Auto="true"
              Style="width: 100%"
              InputAttributes="@(new Dictionary<string,object>{ { "aria-label", "select file" }})">
</RadzenUpload>
<br />
@if (@InProgress)
{
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); z-index: 1000;
            display: flex; align-items: center; justify-content: center;">
        <div class="rz-card" style="padding: 20px;">
            <RadzenText Text="@CurrentStatus" class="rz-m-10" Style="text-align: center" />
            <RadzenProgressBar Value="100" ShowValue="false" Mode="ProgressBarMode.Indeterminate" />
        </div>
    </div>
}
<br />
@if (!string.IsNullOrEmpty(RFPText))
{
    <RadzenCard>
        <RadzenTextArea @bind-Value="RFPText" Rows="10" Style="width: 100%; height: 300px;" />
    </RadzenCard>
}
<!-- hidden canvas used for PDF conversions to PNG -->
<canvas id="pdfCanvas" style="display:none; border:1px solid #ccc;"></canvas>
@code {
    #nullable disable
    private IDisposable registration;
    Radzen.Blazor.RadzenUpload uploader;
    // Allow access to the JSRuntime
    private DotNetObjectReference<Proposal> objRef;

    private string RFPText = string.Empty;
    private bool InProgress = false;
    private string CurrentStatus = "";

    AIResponse result = new AIResponse();

    ZipService objZipService = new ZipService();

    // Run on page load
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Set a reference to the current instance of Home
            objRef = DotNetObjectReference.Create(this);

            // Register the beforeunload event with JavaScript
            await JsRuntime.InvokeVoidAsync("setupBeforeUnload", objRef);

            // Register the location changing handler
            registration =
            Navigation.RegisterLocationChangingHandler(OnLocationChanging);

            // Initialize the ZipService
            objZipService = new ZipService(JsRuntime, localStorage, _SettingsService, LogService);
        }
    }

    async Task EditTemplate(MouseEventArgs args)
    {
        await DialogService.OpenAsync<EditTemplate>(
            "Edit Template",
            new Dictionary<string, object>(),
            new DialogOptions { Width = "700px", Height = "600px" });
    }

    #region JavaScript
    private ValueTask OnLocationChanging(LocationChangingContext context)
    {
        // Get the base URL
        string baseUrl = Navigation.BaseUri;

        // Detect that user is going to counter page
        if (context.TargetLocation != baseUrl)
        {
            // User is navigating away from the page - Zip any files
            // Zip up any files and store in LocalStorage
            Task.Run(async () => await objZipService.ZipTheFiles());
        }

        return ValueTask.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleBeforeUnload()
    {
        // User is navigating away from the page - Zip any files
        // Zip up any files and store in LocalStorage
        await objZipService.ZipTheFiles();
    }
    #endregion

    private async Task OnProposalUpload(UploadChangeEventArgs e)
    {
        try
        {
            InProgress = true;
            CurrentStatus = "Reading RFP...";
            StateHasChanged();

            var file = e.Files.FirstOrDefault();

            if (file is null)
            {
                InProgress = false;
                StateHasChanged();
                return;
            }

            if (Path.GetExtension(file.Name).Equals(".docx", StringComparison.OrdinalIgnoreCase))
            {
                using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
                using var ms = new MemoryStream();
                await stream.CopyToAsync(ms);
                ms.Position = 0;
                var doc = new Document(ms);
                var body = new Body(doc);
                var sb = new StringBuilder();

                foreach (var paragraph in body.Paragraphs)
                {
                    foreach (var run in paragraph.Runs)
                    {
                        sb.Append(run.Text);
                    }
                    sb.AppendLine();
                }

                RFPText = sb.ToString();
            }
            else
            {
                byte[] pdfBytes;
                if (file.ContentType == "application/pdf")
                {
                    var pdfUrl = await PdfService.GetPdfDataUrlAsync(file);
                    if (pdfUrl != null)
                    {
                        await PdfService.RenderPdfToCanvasAsync(pdfUrl, "pdfCanvas");
                        pdfBytes = await PdfService.GetCanvasPngBytesAsync("pdfCanvas");
                    }
                    else
                    {
                        InProgress = false;
                        StateHasChanged();
                        return;
                    }
                }
                else
                {
                    // Read the file as a byte array
                    using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB limit
                    using var ms = new MemoryStream();
                    await stream.CopyToAsync(ms);
                    pdfBytes = ms.ToArray();
                }

                var OCRprompt = await Http.GetStringAsync("Prompts/OCR.prompt");

                var objOrchestratorMethods = new OrchestratorMethods(_SettingsService, LogService);
                var settingsService = new SettingsService();

                result = await objOrchestratorMethods.CallOpenAIFileAsync(settingsService, OCRprompt, pdfBytes);
                RFPText = result.Response;
            }            

            // Clear the selected files so the list is removed
            await uploader.ClearFiles();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            InProgress = false;
            StateHasChanged();

            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Error",
                Detail = ex.Message,
                Duration = 8000
            });
        }
    }

    private async Task ProcessOCRText()
    {
        // Process the OCR text
        var objOrchestratorMethods = new OrchestratorMethods(_SettingsService, LogService);
        var settingsService = new SettingsService();

        InProgress = true;
        CurrentStatus = "Converting...";
        StateHasChanged();

        // Read the contents of \Prompts\Proposal.prompt into prompt
        var Proposalprompt = await Http.GetStringAsync("Prompts/Proposal.prompt");

        // Replace the placeholder in the prompt with the OCR result
        Proposalprompt = Proposalprompt.Replace("{{OCRResult}}", RFPText);

        // Call the OpenAIChatAsync method with the settings, prompt, and OCR result
        result = await objOrchestratorMethods.CallOpenAIAsync(settingsService, Proposalprompt);

        var LLMResult = result.Response;

        CurrentStatus = "Processing RFP...";
        StateHasChanged();

        InProgress = false;
        StateHasChanged();

        // Handle result (show notification, update UI, etc.)
        if (result.Error == "")
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Success,
                Summary = "Success",
                Detail = "Uploaded and processed.",
                Duration = 4000
            });
        }
        else
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Error",
                Detail = $"Failed to process... {result.Error}",
                Duration = 4000
            });
        }
    }

    public void Dispose()
    {
        objRef?.Dispose();
    }
}