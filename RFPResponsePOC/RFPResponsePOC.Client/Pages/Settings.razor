@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@inherits OwningComponentBase
@using static RFPResponsePOC.AI.OrchestratorMethods
@using Newtonsoft.Json;
@using RFPResponsePOC.AI
@using RFPResponsePOC.Client.Services
@using RFPResponsePOC.Model
@using Radzen
@using RFPResponsePOC.Client.Pages
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject SettingsService SettingsService
@inject LogService _LogService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
<h3>Settings</h3>
<RadzenRow AlignItems="AlignItems.Start" Wrap="FlexWrap.Wrap" Gap="1rem" Class="rz-p-sm-12">
    <RadzenColumn Size="12" SizeSM="6">
        <RadzenStack>

            <RadzenFormField Text="API Key:" Variant="@variant">
                <RadzenTextBox @bind-Value="@ApiKey"
                               Type="password"
                               Style="width:450px;"
                               @oninput="HandleApiKeyChange" />
            </RadzenFormField>


            <RadzenFormField Text="OpenAI Model:" Variant="@variant">
                <RadzenDropDown @bind-Value="@AIModel" Data="@availableModels" Style="width: 450px;" TValue="string" />
            </RadzenFormField>

            <div style="display: flex; justify-content: center; align-items: center; gap:10px;">
            @if (!IsOpenAISettingsEntered)
            {
                <RadzenButton Text="An OpenAI API Key is required (Click here to get one)"
                              ButtonStyle="ButtonStyle.Secondary"
                              Click="OpenAIKeyLink"
                              Style="margin-bottom: 10px; width: 500px" />
            }
            else
            {
                <RadzenButton Text="Save"
                              ButtonStyle="ButtonStyle.Primary"
                              Click="SettingsSave"
                              Style="margin-bottom: 10px; width: 200px" />
            }
            </div>

            @if (ZipFileExists)
            {
                <hr />
                <div style="display: flex; justify-content: center; align-items: center; gap:8px;">
                    @if (IsDownloading)
                    {
                        <RadzenButton Disabled="true" Style="min-width:190px;" ButtonStyle="ButtonStyle.Primary">
                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                            <span style="margin-left:4px;">Downloading...</span>
                        </RadzenButton>
                    }
                    else
                    {
                        <RadzenButton Disabled="false" Style="min-width:190px;" ButtonStyle="ButtonStyle.Primary" Click="@(async () => await DownloadSettingsAsync())">Download Settings</RadzenButton>
                    }
                    <RadzenButton Disabled="@IsDownloading" Text="Upload Settings" ButtonStyle="ButtonStyle.Secondary" />
                    <RadzenButton Disabled="@IsDownloading" Text="Delete Saved Settings" ButtonStyle="ButtonStyle.Danger" Click="@(() => objZipService.DeleteZipFile())" />
                </div>
            }
        </RadzenStack>
    </RadzenColumn>
</RadzenRow>
@code {
#nullable disable
    [Parameter] public EventCallback SettingsChanged { get; set; }

    private IDisposable registration;

    private DotNetObjectReference<Settings> objRef;
    ZipService objZipService = new ZipService();

    private OrchestratorMethods objOrchestratorMethods;

    private bool IsOpenAISettingsEntered = false;
    private bool ShowApiKey { get; set; } = false;

    private string ApiKey = "";
    private string AIModel = "gpt-5-mini";
    private string AIEmbeddingModel = "";
    private List<string> availableModels = new List<string> { "o4-mini", "gpt-4o", "gpt-5", "gpt-5-mini" };

    bool ZipFileExists = false;
    Variant variant = Variant.Outlined;
    bool IsDownloading = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupBeforeUnload", objRef);

            registration =
            Navigation.RegisterLocationChangingHandler(OnLocationChanging);

            objZipService = new ZipService(JSRuntime, localStorage, SettingsService, _LogService, DialogService);

            ZipFileExists = await objZipService.IsZipFileExistsAsync();

            SettingsService.LoadSettings();

            objOrchestratorMethods = (OrchestratorMethods)ScopedServices.GetService(typeof(OrchestratorMethods));

            ApiKey = SettingsService.Settings.ApplicationSettings.ApiKey ?? "";
            AIModel = SettingsService.Settings.ApplicationSettings.AIModel;

            IsOpenAISettingsEntered = ApiKey.Length > 1;

            StateHasChanged();
        }
    }

    private void HandleApiKeyChange(ChangeEventArgs e)
    {
        ApiKey = e.Value?.ToString() ?? string.Empty;
        IsOpenAISettingsEntered = !string.IsNullOrWhiteSpace(ApiKey);
    }

    private void ToggleApiKeyVisibility() => ShowApiKey = !ShowApiKey;
    private void APIKeyDetection(KeyboardEventArgs args) => IsOpenAISettingsEntered = true;

    private async Task OpenAIKeyLink() => await JSRuntime.InvokeVoidAsync("open", "https://platform.openai.com/account/api-keys", "_blank");

    private async Task SettingsSave()
    {
        try
        {
            if (!ApiKey.StartsWith("sk-"))
            {
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = "Invalid API Key - must start with: sk-", Duration = 4000 });
                return;
            }
            if (ApiKey.Length < 5)
            {
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = "API Key is required", Duration = 4000 });
                return;
            }
            SettingsService settingsService = new SettingsService();
            SettingsService.ApplicationSettings applicationSettings = settingsService.Settings.ApplicationSettings;
            applicationSettings.ApiKey = ApiKey ?? "";
            applicationSettings.AIModel = AIModel;
            applicationSettings.AIEmbeddingModel = AIEmbeddingModel;
            objOrchestratorMethods = new OrchestratorMethods(SettingsService, _LogService);
            var result = await objOrchestratorMethods.TestAccessAsync(ApiKey, AIModel);
            if (!result)
            {
                NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = "Failed to connect to the AI service. Please check your API Key and Endpoint.", Duration = 8000 });
                await _LogService.WriteToLogAsync($"SettingsSave exception: Failed to connect to the AI service. Please check your API Key and Endpoint.");
                return;
            }
            await settingsService.UpdateSettingsAsync(applicationSettings);
            await _LogService.WriteToLogAsync($"SettingsSave Model: {AIModel}");
            await SettingsChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = "Error", Detail = ex.Message, Duration = 8000 });
            await _LogService.WriteToLogAsync($"SettingsSave exception: {ex.GetBaseException().ToString()}");
        }
    }

    private async Task DownloadSettingsAsync()
    {
        if (IsDownloading) return;
        IsDownloading = true;

        // Ensure the UI is updated before starting the download
        // do a task wait to ensure the UI is responsive
        await Task.Delay(100);

        StateHasChanged();
        try
        {
            await objZipService.ZipTheFiles();
            await objZipService.DownloadZipFile();
        }
        finally
        {
            IsDownloading = false;
            StateHasChanged();
        }
    }

    private ValueTask OnLocationChanging(LocationChangingContext context)
    {
        string baseUrl = Navigation.BaseUri;
        if (context.TargetLocation != baseUrl)
        {
            Task.Run(async () => await objZipService.ZipTheFiles());
        }
        return ValueTask.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleBeforeUnload() => await objZipService.ZipTheFiles();

    public void Dispose() => objRef?.Dispose();
}