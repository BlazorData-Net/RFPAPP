@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@using System.Text
@using System.Text.RegularExpressions
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject IJSRuntime JsRuntime
<h3>Logs</h3>
<div class="row">
    <div class="col">
        <RadzenButton Text="Download Logs" ButtonStyle="ButtonStyle.Success"
                      Click="DownloadLogs"
                      Style="margin-bottom: 10px; width: 150px" />&nbsp;&nbsp;
        <RadzenButton Text="Clear Log" ButtonStyle="ButtonStyle.Danger"
                      Click="ClearLog"
                      Style="margin-bottom: 10px; width: 150px" />&nbsp;&nbsp;
</div>
</div>
<div class="row">
    <div class="col">
        <p>Total Input Tokens: <b>@TotalInputTokens</b> &nbsp;&nbsp;Total Output Tokens: <b>@TotalOutputTokens</b></p>
    </div>
</div>
<RadzenDataGrid AllowFiltering="false" AllowColumnResize="true" AllowAlternatingRows="true"
                PageSize="5" AllowPaging="true" PagerHorizontalAlign="HorizontalAlign.Left"
                Data="@RFPResponsePOCLog" TItem="string" ColumnWidth="300px" ShowPagingSummary="true">
    <Columns>
        <RadzenDataGridColumn TItem="string" Title="Entry">
            <Template>
                <div style="height: 100px; overflow-y: auto; white-space: normal;">
                    @context
                </div>
            </Template>
        </RadzenDataGridColumn>
    </Columns>
</RadzenDataGrid>
<br />
<br />
<br />
<br />
<br />
<br />

@code {
    string RFPResponsePOCLogPath = "";
    string[] RFPResponsePOCLog;
    int TotalInputTokens = 0;
    int TotalOutputTokens = 0;

    // Run on page load
    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            RFPResponsePOCLogPath = @"/RFPResponsePOC/RFPResponsePOCLog.csv";

            // Read the lines from the .csv file
            using (var file = new System.IO.StreamReader(RFPResponsePOCLogPath))
            {
                RFPResponsePOCLog = file.ReadToEnd().Split('\n');

                if (RFPResponsePOCLog[RFPResponsePOCLog.Length - 1].Trim() == "")
                {
                    RFPResponsePOCLog = RFPResponsePOCLog.Distinct().Take(RFPResponsePOCLog.Length - 1).ToArray();
                }
            }

            CalculateTokenTotals();

            StateHasChanged();
        }
    }

    private void ClearLog()
    {
        try
        {
            using (var streamWriter = new StreamWriter(RFPResponsePOCLogPath))
            {
                streamWriter.WriteLine(string.Join("\n", "Log cleared on " + DateTime.Now));
            }

            // Read the lines from the .csv file
            using (var file = new System.IO.StreamReader(RFPResponsePOCLogPath))
            {
                RFPResponsePOCLog = file.ReadToEnd().Split('\n');
                if (RFPResponsePOCLog[RFPResponsePOCLog.Length - 1].Trim() == "")
                {
                    RFPResponsePOCLog = RFPResponsePOCLog.Take(RFPResponsePOCLog.Length - 1).ToArray();
                }
            }

            CalculateTokenTotals();

            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Success,
                Summary = "Success",
                Detail = "Log Cleared",
                Duration = 4000
            });
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Error",
                Detail = ex.Message,
                Duration = 4000
            });
        }
    }

    private async Task DownloadLogs()
    {
        try
        {
            if (RFPResponsePOCLog == null || RFPResponsePOCLog.Length == 0)
            {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Warning,
                Summary = "Warning",
                Detail = "No logs available to download",
                Duration = 4000
            });
            return;
        }

            // Create text content with double line breaks
            var textContent = string.Join("\n\n", RFPResponsePOCLog) + "\n\n";
            var bytes = Encoding.UTF8.GetBytes(textContent);
            var base64String = Convert.ToBase64String(bytes);

            // Generate filename with timestamp
            var fileName = $"RFPResponsePOC_Log_{DateTime.Now:yyyyMMdd_HHmmss}.txt";

            // Use JavaScript to download the file
            await JsRuntime.InvokeVoidAsync("eval", $@"
                const bytes = atob('{base64String}');
                const byteNumbers = new Array(bytes.length);
                for (let i = 0; i < bytes.length; i++) {{
                    byteNumbers[i] = bytes.charCodeAt(i);
                }}
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], {{ type: 'text/plain;charset=utf-8;' }});
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', '{fileName}');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            ");

            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Success,
                Summary = "Success",
                Detail = "Logs downloaded successfully",
                Duration = 4000
            });
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Error",
                Detail = $"Failed to download logs: {ex.Message}",
                Duration = 4000
            });
        }
    }

    private void CalculateTokenTotals()
    {
        TotalInputTokens = 0;
        TotalOutputTokens = 0;
        if (RFPResponsePOCLog != null)
        {
            foreach (var line in RFPResponsePOCLog)
            {
                var match = Regex.Match(line, @"Tokens - Input: (\d+), Output: (\d+)");
                if (match.Success)
                {
                    TotalInputTokens += int.Parse(match.Groups[1].Value);
                    TotalOutputTokens += int.Parse(match.Groups[2].Value);
                }
            }
        }
    }
}